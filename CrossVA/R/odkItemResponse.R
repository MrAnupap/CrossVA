#' Translate ODK relevant field
#'
#' \code{translate} converts conditions in ODK to R.
#'
#' @param relevant A string from ODK$relevant that needs to be translated.
#'
#' @details
#' This is a worker function.
#' 
#' @examples
#' \dontrun{
#' ## Example with 2016 WHO VA instrument version 1.5.1
#' record_f_name151 <- system.file("sample",
#'                                 "who151_odk_export.csv",
#'                                 package = "CrossVA")
#' records151 <- read.csv(record_f_name151, stringsAsFactors = FALSE)
#' 
#' form_f_name151 <- system.file("forms",
#'                               "WHOVA2016_v1_5_1_XLS_form_for_ODK_survey.csv",
#'                               package = "CrossVA")
#' form151 <- read.csv2(form_f_name151, stringsAsFactors = FALSE)
#' death <- records151[1,]
#' 
#' relevant <- form151$relevant[15]
#' translate(relevant)
#' }
#'
#' @importFrom stringi stri_replace_all_regex stri_count_words
#' @export
#'
translate <- function (relevant) {

    # remove \n
    pattern_selected <- "\n"
    new_relevant <- stri_replace_all_regex(relevant, pattern_selected, " ")

    # replace = with == (but not for >= or <= or !=)
    pattern_selected <- "(?<![>|<|!])="
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_selected, "==")

    # translate selected() -- maybe have separate functions for these
    pattern_selected <- "(?<!not\\()selected\\(\\$\\{([^\\}]+)\\}[^']+('[^']+')\\)"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_selected, "death\\$$1 == $2")

    # translate not(selected())
    pattern_not_selected <- "not\\(selected\\(\\$\\{([^\\}]+)\\}[^']+('[^']+')\\)\\)"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_not_selected, "death\\$$1 != $2")

    # translate ${field_name} (separately for !=, =, >, and <)
    # \\1 = field name, \\2 = }, \\3 = relational operator/comparators
    pattern_field_eq <- "(?<!selected\\()\\$\\{([^\\}]+)(\\})[:space:]*([=|!|>|<]=*)[:space:]*"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_field_eq, "death\\$$1 $3 ")
 
    # translate or replace " or " with " | "
    new_relevant <- stri_replace_all_regex(new_relevant, " or ", " | ")
    new_relevant <- stri_replace_all_regex(new_relevant, "\\)or", ") | (")
    new_relevant <- stri_replace_all_regex(new_relevant, "or\\(", ") | (")
    
    # translate and odkForm$relevant[437]
    new_relevant <- stri_replace_all_regex(new_relevant, "[:space:]+and[:space:]+", " & ")
    new_relevant <- stri_replace_all_regex(new_relevant, "\\)and", " & ")
    new_relevant <- stri_replace_all_regex(new_relevant, "and\\(", " & ")

    # translate 'NaN' (note previous conversions with = and with field name)
    ## is.na() == TRUE
    pattern_field_eq <- "death\\$([^[:space:][:punct:]]+)[:space:]*==[:space:]*'NaN'"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_field_eq, "is.na(death\\$$1)")
    ## is.na() == FALSE
    pattern_field_neq <- "death\\$([^[:space:][:punct:]]+)[:space:]*!=[:space:]*'NaN'"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_field_neq, "!is.na(death\\$$1)")

    # translate string-length(${ageInMonthsByYear}) = 0)) with nchar
    pattern_field <- "string-length\\(\\$\\{([^\\}]+)\\}\\)"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_field, "nchar(death\\$$1)")

    # translate count-selected 
    pattern_field <- "count-selected\\(\\$\\{([^\\}]+)\\}\\)"
    new_relevant <- stri_replace_all_regex(new_relevant, pattern_field, "stri_count_words(death\\$$1)")

    ## devtools::test_file('../tests/testthat/test-item-response.R')
    return(new_relevant)
}


#' Construct item names that capture the hierarchical of an ODK questionnare.
#'
#' \code{itemHierarchy} map the ODK questionnaire hierarchy (i.e. a replication
#' of the field names generated by ODK Aggregate and used in the CSV export).
#'
#' @param odk_form A data frame containing an ODK form.
#'
#' @details
#' Returns the the same data frame, but with an additional column
#' consisting of the group names each item belongs to.  The group names
#' are separated by ".".
#' 
#' @examples
#' \dontrun{
#' ## Example with 2016 WHO VA instrument version 1.5.1
#' 
#' form_f_name151 <- system.file("forms",
#'                               "WHOVA2016_v1_5_1_XLS_form_for_ODK_survey.csv",
#'                               package = "CrossVA")
#' form151 <- read.csv2(form_f_name151, stringsAsFactors = FALSE)
#' item_groups <- itemHierarchy(form151)$item_groups
#' }
#'
#' @importFrom stringi stri_replace_all_regex stri_count_words
#' @export
#'
itemHierarchy <- function (odk_form) {

    skip_row <- odk_form$type == ""
    new_form <- odk_form
    new_form$item_groups <- ""
    current_name <- ""
    n_groups <- 0

    nNames <- function (item_names) {
        # return the number of groups in groupNames
        split_names <- strsplit(item_names, "\\.")
        all_names <- unlist(split_names)
        return (length(all_names))
    }

    removeLastName <- function (item_names) {
        # remove last group name; groups separated by a period
        split_names <- strsplit(item_names, "\\.")
        all_names <- unlist(split_names)
        n <- length(all_names)
        names_to_keep <- unlist(split_names)[-n]
        return (paste0(names_to_keep, collapse = "."))
    }
    
    for (i in 1:length(skip_row)) {

        if (skip_row[i]) next

        if (new_form$type[i] == "begin group" & nNames(current_name) == 0) {
            current_name <- new_form$name[i]
            n_groups <- n_groups + 1
            new_form$item_groups[i] <- current_name
        } else if (new_form$type[i] == "begin group" & nNames(current_name) > 0) {
            current_name <- paste0(c(current_name, new_form$name[i]), collapse = ".")
            n_groups <- n_groups + 1
            new_form$item_groups[i] <- current_name
        } else if (new_form$type[i] == "end group") {
            current_name <- removeLastName(current_name)
            n_groups <- n_groups - 1
            next
        } else {
            current_name <- paste0(c(current_name, new_form$name[i]),
                                   collapse = ".")
            new_form$item_groups[i] <- current_name
            current_name <- removeLastName(current_name)
        }
    }

    ## devtools::test_file('../tests/testthat/test-item-response.R')
    return (new_form)
}

#' Calculate item missingness.
#'
#' \code{itemMissing} 
#'
#' @param odk_data A data frame with ODK data
#' @param odk_form A data frame containing an ODK form.
#' @param id_col A string with column name in odk_data with ID (default is "meta.instanceID")
#'
#' @details
#' List with two data frames Deaths and Items.
#' 
#' @examples
#' \dontrun{
#' ## Example with 2016 WHO VA instrument version 1.5.1
#' 
#' record_f_name151 <- system.file("sample",
#'                                 "who151_odk_export.csv",
#'                                 package = "CrossVA")
#' records151 <- read.csv(record_f_name151, stringsAsFactors = FALSE)
#'
#' 
#' form_f_name151 <- system.file("forms",
#'                               "WHOVA2016_v1_5_1_XLS_form_for_ODK_survey.csv",
#'                               package = "CrossVA")
#' form151 <- read.csv2(form_f_name151, stringsAsFactors = FALSE)
#' results <- itemMissing(records151, form151)
#' }
#'
#' @export
#'
itemMissing <- function(odk_data, odk_form, id_col = "meta.instanceID") {

    ## record_f_name151 <- system.file("sample",
    ##                                 "who151_odk_export.csv",
    ##                                 package = "CrossVA")
    ## records151 <- read.csv(record_f_name151, stringsAsFactors = FALSE)

    ## form_f_name151 <- system.file("forms",
    ##                               "WHOVA2016_v1_5_1_XLS_form_for_ODK_survey.csv",
    ##                               package = "CrossVA")
    ## form151 <- read.csv2(form_f_name151, stringsAsFactors = FALSE)
    ## odk_data <- records151
    ## odk_form <- form151
    ## id_col = "meta.instanceID"

    ## set up input data
    split_names <- strsplit(names(odk_data), "\\.")
    death_fnames <- unlist(lapply(split_names, function (x) x[length(x)]))
    names(odk_data) <- death_fnames
    new_odk_form <- itemHierarchy(odk_form)
    clean_form <- new_odk_form[new_odk_form$name != "",]

    ## set up output data
    n_deaths <- nrow(odk)
    index_ID <- which(stri_endswith_fixed(names(odk_data), id_col))
    if (length(index_ID)) {
        DEATHS <- data.frame(ID = odk_data[, index_ID],
                             n_items <- rep(NA, n_deaths),
                             n_ref <- rep(NA, n_deaths),
                             n_dk <- rep(NA, n_deaths),
                             n_miss <- rep(NA, n_deaths))
    } else {
        ## message("Did not find id_col, so assigning row numbers for IDs.",
        ##         call. = FALSE)
        DEATHS <- data.frame(ID = 1:n_deaths,
                             n_items <- rep(NA, n_deaths),
                             n_ref <- rep(NA, n_deaths),
                             n_dk <- rep(NA, n_deaths),
                             n_miss <- rep(NA, n_deaths))
    }

    ITEMS <- clean_form[, c('type', 'name', 'relevant', 'required')]
    ITEMS$n_asked <- rep(NA, nrow(clean_form))
    ITEMS$n_ref <- rep(NA, nrow(clean_form))
    ITEMS$n_dk <- rep(NA, nrow(clean_form))
    ITEMS$n_miss <- rep(NA, nrow(clean_form))
    ## dim(ITEMS)

    ## warning message about which fields are in data, but not in form
    ## and vice versa.

    ## fill in data
    ## loop deaths
    for (i in 1:ncol(odk_data)) {

        ## i=1  i = 16
        ## death_fnames[i] %in% clean_form$name
        ## i=2
        ## death_fnames[i] %in% clean_form$name
        ## form151$name[which(clean_form151$name == deathFNames[i])]
        index_form <- which(clean_form$name == death_fnames[i])
        if (length(index_form) == 0) next
        
        ## clean_form$relevant[index_form]
        depends <- strsplit(clean_form$item_group[index_form], "\\.")
        depends <- unlist(depends)
        index_depends <- which(clean_form$name %in% depends)
        depends_relevant <- clean_form$relevant[index_depends]
        translated_relevant <- vapply(depends_relevant, translate,
                                      FUN.VALUE = character(1),
                                      USE.NAMES = FALSE)
        translated_relevant <- translated_relevant[!(translated_relevant == "")]
        combined_relevant <- paste0("(", translated_relevant, ")", collapse = " & ")
        which((odk_data$Id10013 == 'yes') & (odk_data$Id10020 == 'yes'))
        odk_data[(odk_data$Id10013 == 'yes') & (odk_data$Id10020 == 'yes'), death_fnames[i]]
        
        # new_relevant
        # eval(parse(text = paste0("death$", new_relevant)))
        # with(data, eval(parse(text = new_relevant)))

    # That's all folks!
    results <- list(Deaths <- DEATHS,
                    Items <- ITEMS)
    return (results)

}
